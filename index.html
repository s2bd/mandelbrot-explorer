<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<title>MandelExplorer — v0.9</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#0f1724cc;
    --accent:#7dd3fc;
    --muted:#9aa6b2;
    --glass: rgba(255,255,255,0.04);
    --btn-size:48px;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#05060a 0%, #071026 100%);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  #app{position:relative;height:100vh;overflow:hidden;display:flex;align-items:center;justify-content:center;}
  canvas{display:block;width:100%;height:100%;background:transparent;}
  /* Floating controls */
  .controls{
    position: absolute;
    right: 18px;
    top: 18px;
    display:flex;
    flex-direction:column;
    gap:10px;
    z-index: 50;
  }
  .btn{
    width:var(--btn-size);
    height:var(--btn-size);
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:12px;
    background:var(--panel);
    color:white;
    box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    border:1px solid rgba(255,255,255,0.02);
    cursor:pointer;
    user-select:none;
    font-weight:600;
    font-size:16px;
  }
  .btn:hover{transform:translateY(-3px);transition:transform 0.12s}
  .btn:active{transform:translateY(0)}
  /* Small Julia viewport */
  #juliaWrap{
    position:absolute;
    left:18px;
    top:18px;
    width:320px;
    height:240px;
    background:var(--glass);
    border-radius:10px;
    overflow:hidden;
    z-index:40;
    box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    display:flex;
    flex-direction:column;
    border:1px solid rgba(255,255,255,0.03);
  }
  #juliaHeader{
    padding:6px 10px;
    font-size:13px;
    color:var(--muted);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    display:flex;
    align-items:center;
    gap:8px;
  }
  #juliaCanvas{flex:1; display:block; width:100%; height:100%;}
  /* Bottom-left info */
  .info{
    position:absolute;
    left:18px;
    bottom:18px;
    color:#cfe8ff;
    font-size:13px;
    z-index:40;
    background:rgba(6,10,16,0.3);
    padding:8px 12px;
    border-radius:8px;
    backdrop-filter: blur(6px);
    border:1px solid rgba(255,255,255,0.02);
  }
  /* splash */
  #splash{
    position:absolute; z-index:100; inset:0; display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg, rgba(2,6,23,0.6), rgba(2,6,23,0.2));
    pointer-events:none;
  }
  .splashCard{
    pointer-events:auto;
    background:linear-gradient(180deg,#fff,#f7f8fb);
    color:#071027;
    padding:30px 36px;
    border-radius:12px;
    text-align:center;
    box-shadow:0 30px 60px rgba(3,9,24,0.55);
    min-width:320px;
  }
  .splashTitle{font-weight:900;font-size:36px;letter-spacing:1px;}
  .splashSub{margin-top:8px;color:#7a8190;font-size:14px;}
  /* error modal */
  #errorModal{
    position:fixed; inset:0; z-index:999; display:none; align-items:center; justify-content:center; background:rgba(2,4,10,0.6);
  }
  .errCard{background:white;color:#081025;padding:20px;border-radius:10px;min-width:300px;max-width:720px;}
  .errTitle{font-weight:800;margin-bottom:8px;}
  .errBody{font-family:monospace;font-size:13px;color:#112233;white-space:pre-wrap; max-height:360px; overflow:auto;}
  .errActions{display:flex;gap:8px; margin-top:12px; justify-content:flex-end;}
  .small{font-size:12px;color:var(--muted)}
  /* responsiveness */
  @media(max-width:420px){
    #juliaWrap{width:200px;height:140px;left:10px;top:10px}
    .controls{right:10px;top:10px}
  }
.floating-pill{
  position:fixed;
  z-index:99999; /* ensure above all */
  bottom:1rem;
  display:flex;align-items:center;
  gap:0.5rem;
  padding:0.5rem 1rem;
  border-radius:9999px;
  background:rgba(255,255,255,0.15);
  backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);
  color:#fff;font-family:sans-serif;
  font-size:clamp(0.75rem,1.8vw,0.9rem);
  cursor:pointer;
  box-shadow:0 0.25rem 0.75rem rgba(0,0,0,0.25);
  transition:transform .2s;
  text-decoration:none;
}
.floating-pill:hover{transform:translateY(-0.125rem);}
.left-pill{left:1rem;}
.right-pill{right:1rem;}
.floating-pill i{font-size:clamp(0.85rem,2vw,1rem);}
</style>
</head>
<body>
<div id="app" role="application" aria-label="MandelExplorer fractal explorer">
  <canvas id="mainCanvas"></canvas>

  <div id="juliaWrap" style="display:none;">
    <div id="juliaHeader">Julia preview (hover Mandelbrot)</div>
    <canvas id="juliaCanvas" width="640" height="480"></canvas>
  </div>

  <div class="controls" aria-hidden="false">
    <div class="btn" id="zoomInBtn" title="Zoom in (W)">+</div>
    <div class="btn" id="zoomOutBtn" title="Zoom out (S)">−</div>
    <div class="btn" id="toggleJuliaBtn" title="Toggle Julia viewport">J</div>
    <div class="btn" id="resetBtn" title="Reset view">⟲</div>
    <div class="btn" id="fullscreenBtn" title="Toggle fullscreen">⤢</div>
  </div>

  <div class="floating-pill left-pill" id="infoBox">MandelExp • Zoom: 1× • Iter: 512</div>

  <!-- splash -->
  <div id="splash" aria-hidden="false">
    <div class="splashCard" role="dialog" aria-label="MandelEx splash">
      <div class="splashTitle">MandelEXP</div>
      <div class="splashSub">version 0.9</div>
      <div style="height:14px"></div>
      <div style="color:#001122;font-size:14px">KYS Math Tools</div>
    </div>
  </div>

  <!-- error modal -->
  <div id="errorModal" role="alertdialog" aria-hidden="true">
    <div class="errCard">
      <div class="errTitle">An error occurred</div>
      <div class="errBody" id="errBody">Unknown error</div>
      <div class="errActions">
        <button id="downloadLog">Download Log</button>
        <button id="closeErr">Close</button>
      </div>
    </div>
  </div>
</div>
    <div id="coordTooltip" style="position:fixed;pointer-events:none;z-index:100000;padding:6px 12px;background:rgba(255,255,255,0.15);backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);color:#fff;border-radius:8px;font-family:sans-serif;font-size:0.85rem;display:none;"></div>
<script>
(() => {
  // Basic utilities
  function $(id){return document.getElementById(id);}
  const mainCanvas = $('mainCanvas');
  const juliaCanvas = $('juliaCanvas');
  const juliaWrap = $('juliaWrap');
  const infoBox = $('infoBox');
  const splash = $('splash');
  const errorModal = $('errorModal');
  const errBody = $('errBody');
  const downloadLog = $('downloadLog');
  const closeErr = $('closeErr');

  // configuration
  const CONFIG = {
    baseIterations: 512,
    maxIterations: 10000,
    zoomFactor: 1.15,
    panSpeed: 0.06, // fraction of viewport per arrow-press
    juliaEnabled: false
  };

  // state
  let state = {
    // complex-plane view center and scale (scale = pixels per unit? We'll use scale as "width of viewport in complex units")
    centerX: -0.6,
    centerY: 0.0,
    scale: 3.5, // width of view in complex plane
    pixelRatio: Math.max(1, window.devicePixelRatio || 1),
    iterations: CONFIG.baseIterations,
    dragging: false,
    dragStart: null,
    lastMouse: {x:0,y:0, overCanvas:false},
    juliaC: {x:0,y:0}
  };

  // GL helper
  function createContext(canvas){
    const gl = canvas.getContext('webgl2', {antialias:false, preserveDrawingBuffer:false});
    if(!gl) throw new Error('WebGL2 not supported in this browser.');
    return gl;
  }

  // Shader helpers
  function compileShader(gl, type, source){
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      const msg = gl.getShaderInfoLog(s);
      gl.deleteShader(s);
      throw new Error('Shader compile error: ' + msg);
    }
    return s;
  }
  function createProgram(gl, vsSrc, fsSrc){
    const vs = compileShader(gl, gl.VERTEX_SHADER, vsSrc);
    const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSrc);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
      const msg = gl.getProgramInfoLog(prog);
      gl.deleteProgram(prog);
      throw new Error('Program link error: ' + msg);
    }
    return prog;
  }

  // Basic full-screen quad vertex shader
  const vsSource = `#version 300 es
  precision highp float;
  in vec2 a_pos;
  out vec2 v_uv;
  void main(){
    v_uv = (a_pos + 1.0) * 0.5;
    gl_Position = vec4(a_pos, 0.0, 1.0);
  }`;

  // Fragment shader for Mandelbrot and Julia
  // - supports switching mode via uniform bool u_isJulia
  // - uses highp floats
  const fsSource = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  out vec4 outColor;

  uniform vec2 u_center; // center in complex plane
  uniform float u_scale; // width of view (complex units)
  uniform vec2 u_resolution; // canvas resolution
  uniform int u_iterations;
  uniform bool u_isJulia;
  uniform vec2 u_julia_c; // for julia set
  uniform float u_time;

  // color palette
  vec3 palette(float t){
    // smoothIter multi-hue palette
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.0, 0.33, 0.67);
    return a + b*cos(6.28318*(c*t + d));
  }

  void main(){
    // map pixel to complex plane: x in [center.x - scale/2, center.x + scale/2]
    vec2 frag = v_uv * u_resolution;
    vec2 uvCentered = (frag - 0.5*u_resolution) / min(u_resolution.x, u_resolution.y); // normalized by min dimension
    // adjust so scale maps to width of viewport
    vec2 c = u_center + uvCentered * vec2(u_scale, u_scale * (u_resolution.y/u_resolution.x));
    vec2 z = c;
    vec2 c_j = u_julia_c;

    int maxIter = u_iterations;
    float iterCount = 0.0;

    if(u_isJulia){
      z = c;
      c = c_j;
    } else {
      // mandelbrot: z = 0, c = mapped point
      z = vec2(0.0);
      // c is already set from mapping
    }

    float bail = 4.0;
    float smoothIter = 0.0;

    int i;
    for(i=0;i<maxIter;i++){
      // z = z^2 + c
      float x = (z.x*z.x - z.y*z.y) + c.x;
      float y = (2.0*z.x*z.y) + c.y;
      z = vec2(x,y);
      if(dot(z,z) > bail){
        // smoothIter iteration count: n + 1 - log(log|z|)/log 2
        float log_zn = log(dot(z,z)) / 2.0;
        float nu = log(log_zn / log(2.0)) / log(2.0);
        smoothIter = float(i) + 1.0 - nu;
        iterCount = smoothIter;
        break;
      }
    }
    if(i==maxIter){
      // interior — color black or dark
      outColor = vec4(0.0, 0.0, 0.0, 1.0);
      return;
    }

    // normalized t
    float t = iterCount / float(maxIter);
    // enhance contrast
    t = pow(t, 0.45);
    vec3 col = palette(t);
    // add subtle shading by distance
    col *= 0.9 + 0.2 * (1.0 - t);
    outColor = vec4(col, 1.0);
  }`;

  // create GL programs
  const glMain = createContext(mainCanvas);
  const glJulia = createContext(juliaCanvas);

  const progMain = createProgram(glMain, vsSource, fsSource);
  const progJulia = createProgram(glJulia, vsSource, fsSource);

  // prepare full-screen quad
  function setupQuad(gl, program){
    const posLoc = gl.getAttribLocation(program, 'a_pos');
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    const data = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
    gl.bindVertexArray(null);
    return {vao, buf};
  }
  const quadMain = setupQuad(glMain, progMain);
  const quadJulia = setupQuad(glJulia, progJulia);

  // uniform setters
  function setCommonUniforms(gl, prog, w, h, centerX, centerY, scale, iterations, isJulia, juliaCx, juliaCy){
    gl.useProgram(prog);
    const locCenter = gl.getUniformLocation(prog, 'u_center');
    const locScale = gl.getUniformLocation(prog, 'u_scale');
    const locRes = gl.getUniformLocation(prog, 'u_resolution');
    const locIter = gl.getUniformLocation(prog, 'u_iterations');
    const locIsJulia = gl.getUniformLocation(prog, 'u_isJulia');
    const locJuliaC = gl.getUniformLocation(prog, 'u_julia_c');
    gl.uniform2f(locCenter, centerX, centerY);
    gl.uniform1f(locScale, scale);
    gl.uniform2f(locRes, w, h);
    gl.uniform1i(locIter, iterations);
    gl.uniform1i(locIsJulia, isJulia?1:0);
    gl.uniform2f(locJuliaC, juliaCx, juliaCy);
  }

  // resize handling
  function resizeCanvasToDisplaySize(canvas, gl){
    const dpr = state.pixelRatio;
    const width = Math.max(1, Math.floor(canvas.clientWidth * dpr));
    const height = Math.max(1, Math.floor(canvas.clientHeight * dpr));
    if(canvas.width !== width || canvas.height !== height){
      canvas.width = width;
      canvas.height = height;
      gl.viewport(0,0,width,height);
      return true;
    }
    return false;
  }

  // render functions
  function renderMain(){
    const gl = glMain;
    resizeCanvasToDisplaySize(mainCanvas, gl);
    const w = mainCanvas.width;
    const h = mainCanvas.height;
    // adapt iterations based on zoom level (more zoom -> more iterations)
    const zoom = 3.5 / state.scale; // approximate zoom factor
let iters = Math.floor(CONFIG.baseIterations * Math.log2(1 + zoom*2));
iters = Math.min(CONFIG.maxIterations, Math.max(64, iters));
state.iterations = iters;


    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    setCommonUniforms(gl, progMain, w, h, state.centerX, state.centerY, state.scale, iters, false, 0.0, 0.0);
    gl.bindVertexArray(quadMain.vao);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // update info
    const zoomText = (3.5 / state.scale).toFixed(2) + '×';
    infoBox.textContent = `MandelEXP • Zoom: ${zoomText} • Iter: ${iters}`;
  }

  function renderJulia(){
    if(!CONFIG.juliaEnabled) return;
    const gl = glJulia;
    resizeCanvasToDisplaySize(juliaCanvas, gl);
    const w = juliaCanvas.width;
    const h = juliaCanvas.height;
    const iters = Math.min(800, Math.max(120, Math.floor(state.iterations/2)));
    setCommonUniforms(gl, progJulia, w, h, 0.0, 0.0, 3.0, iters, true, state.juliaC.x, state.juliaC.y);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindVertexArray(quadJulia.vao);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  // initial sizing to occupy available space
  function fitCanvas(){
    // make canvas fill parent
    mainCanvas.style.width = '100%';
    mainCanvas.style.height = '100%';
    mainCanvas.width = Math.floor(mainCanvas.clientWidth * state.pixelRatio);
    mainCanvas.height = Math.floor(mainCanvas.clientHeight * state.pixelRatio);
    glMain.viewport(0,0,mainCanvas.width, mainCanvas.height);

    // julia canvas auto-adjust in CSS - drawing code will resize
  }
  fitCanvas();

  // Input handling for pan/zoom
  function screenToComplex(x, y, canvas){
    const rect = canvas.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const px = x - rect.left;
    const py = y - rect.top;
    // normalized uv centered
    const nx = (px - rect.width/2) / Math.min(rect.width, rect.height);
    const ny = (py - rect.height/2) / Math.min(rect.width, rect.height);
    const mappedX = state.centerX + nx * state.scale;
    const mappedY = state.centerY + ny * state.scale * (rect.height/rect.width);
    return {x: mappedX, y: mappedY};
  }

  // Mouse interactions
  let lastWheelTime = 0;
  mainCanvas.addEventListener('wheel', e => {
    try {
      e.preventDefault();
      // zoom at cursor
      const delta = Math.sign(e.deltaY);
      const zoomFactor = Math.pow(CONFIG.zoomFactor, delta); // wheel up -> zoom in
      // map mouse to complex plane
      const rect = mainCanvas.getBoundingClientRect();
      const mx = e.clientX, my = e.clientY;
      const before = screenToComplex(mx, my, mainCanvas);
      state.scale *= zoomFactor;
      // after mapping of same screen point should remain anchored: adjust center
      const after = screenToComplex(mx, my, mainCanvas);
      state.centerX += (before.x - after.x);
      state.centerY += (before.y - after.y);
      renderMain();
      if(CONFIG.juliaEnabled) renderJulia();
    } catch(err){ handleError(err); }
  }, {passive:false});

  // Panning with middle button or left button drag
  mainCanvas.addEventListener('pointerdown', e => {
    try {
      mainCanvas.setPointerCapture(e.pointerId);
      state.dragging = true;
      state.dragStart = {x:e.clientX, y:e.clientY, centerX: state.centerX, centerY: state.centerY};
    } catch(err){ handleError(err); }
  });
  mainCanvas.addEventListener('pointermove', e => {
    try {
      state.lastMouse = {x: e.clientX, y: e.clientY, overCanvas: true};
      if(state.dragging && state.dragStart){
        const dx = e.clientX - state.dragStart.x;
        const dy = e.clientY - state.dragStart.y;
        const rect = mainCanvas.getBoundingClientRect();
        const nx = dx / Math.min(rect.width, rect.height);
        const ny = dy / Math.min(rect.width, rect.height);
        state.centerX = state.dragStart.centerX - nx * state.scale;
        state.centerY = state.dragStart.centerY + ny * state.scale * (rect.height/rect.width);
        renderMain();
        if(CONFIG.juliaEnabled) renderJulia();
      } else {
        // update Julia C by hovering point when julia enabled
        if(CONFIG.juliaEnabled){
          const c = screenToComplex(e.clientX, e.clientY, mainCanvas);
          state.juliaC.x = c.x;
          state.juliaC.y = c.y;
          renderJulia();
        }
      }
    } catch(err){ handleError(err); }
  });
  mainCanvas.addEventListener('pointerup', e => {
    try {
      state.dragging = false;
      state.dragStart = null;
      mainCanvas.releasePointerCapture(e.pointerId);
    } catch(err){ handleError(err); }
  });
  mainCanvas.addEventListener('pointerleave', e => {
    state.lastMouse.overCanvas = false;
  });

  // keyboard controls
  window.addEventListener('keydown', e => {
    try {
      const step = state.scale * CONFIG.panSpeed;
      if(e.key === 'ArrowLeft'){ state.centerX -= step; renderMain(); if(CONFIG.juliaEnabled) renderJulia(); }
      else if(e.key === 'ArrowRight'){ state.centerX += step; renderMain(); if(CONFIG.juliaEnabled) renderJulia(); }
      else if(e.key === 'ArrowUp'){ state.centerY += step; renderMain(); if(CONFIG.juliaEnabled) renderJulia(); }
      else if(e.key === 'ArrowDown'){ state.centerY -= step; renderMain(); if(CONFIG.juliaEnabled) renderJulia(); }
      else if(e.key === 'w' || e.key === 'W'){ // zoom in
        const rect = mainCanvas.getBoundingClientRect();
        // use center of canvas for keyboard zoom
        const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
        const before = screenToComplex(cx, cy, mainCanvas);
        state.scale /= CONFIG.zoomFactor;
        const after = screenToComplex(cx, cy, mainCanvas);
        state.centerX += (before.x - after.x);
        state.centerY += (before.y - after.y);
        renderMain(); if(CONFIG.juliaEnabled) renderJulia();
      }
      else if(e.key === 's' || e.key === 'S'){ // zoom out
        const rect = mainCanvas.getBoundingClientRect();
        const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
        const before = screenToComplex(cx, cy, mainCanvas);
        state.scale *= CONFIG.zoomFactor;
        const after = screenToComplex(cx, cy, mainCanvas);
        state.centerX += (before.x - after.x);
        state.centerY += (before.y - after.y);
        renderMain(); if(CONFIG.juliaEnabled) renderJulia();
      }
    } catch(err){ handleError(err); }
  });

  // buttons
  $('zoomInBtn').addEventListener('click', ()=>{
    try {
      const rect = mainCanvas.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      const before = screenToComplex(cx, cy, mainCanvas);
      state.scale /= CONFIG.zoomFactor;
      const after = screenToComplex(cx, cy, mainCanvas);
      state.centerX += (before.x - after.x);
      state.centerY += (before.y - after.y);
      renderMain(); if(CONFIG.juliaEnabled) renderJulia();
    } catch(err){ handleError(err); }
  });
  $('zoomOutBtn').addEventListener('click', ()=>{
    try {
      const rect = mainCanvas.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      const before = screenToComplex(cx, cy, mainCanvas);
      state.scale *= CONFIG.zoomFactor;
      const after = screenToComplex(cx, cy, mainCanvas);
      state.centerX += (before.x - after.x);
      state.centerY += (before.y - after.y);
      renderMain(); if(CONFIG.juliaEnabled) renderJulia();
    } catch(err){ handleError(err); }
  });
  $('resetBtn').addEventListener('click', ()=>{
    state.centerX = -0.6; state.centerY = 0.0; state.scale = 3.5; renderMain(); if(CONFIG.juliaEnabled) renderJulia();
  });
  $('toggleJuliaBtn').addEventListener('click', ()=>{
    CONFIG.juliaEnabled = !CONFIG.juliaEnabled;
    juliaWrap.style.display = CONFIG.juliaEnabled ? 'flex' : 'none';
    if(CONFIG.juliaEnabled){
      // set current hover point as julia seed
      const last = state.lastMouse;
      if(last.overCanvas){
        const c = screenToComplex(last.x, last.y, mainCanvas);
        state.juliaC.x = c.x; state.juliaC.y = c.y;
      } else {
        state.juliaC.x = state.centerX; state.juliaC.y = state.centerY;
      }
      renderJulia();
    }
  });
  $('fullscreenBtn').addEventListener('click', async ()=>{
    try {
      if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    } catch(err){ handleError(err); }
  });

  // splash auto-hide after 3 seconds
  setTimeout(()=>{ if(splash) { splash.style.display = 'none'; } }, 3000);

  // fullscreen resizing and responsiveness
  window.addEventListener('resize', ()=>{
    state.pixelRatio = Math.max(1, window.devicePixelRatio || 1);
    fitCanvas();
    renderMain();
    if(CONFIG.juliaEnabled) renderJulia();
  });

  // initial render
  try {
    renderMain();
    if(CONFIG.juliaEnabled) renderJulia();
  } catch(err){ handleError(err); }

  // global error handling
  function handleError(err){
    console.error(err);
    // show modal
    errorModal.style.display = 'flex';
    errorModal.setAttribute('aria-hidden','false');
    errBody.textContent = (err && err.stack) ? err.stack : String(err);
    // provide download of log
    downloadLog.onclick = ()=> {
      const blob = new Blob([errBody.textContent], {type:'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'mandelex-error-log.txt';
      a.click();
      URL.revokeObjectURL(url);
    };
    closeErr.onclick = ()=> {
      errorModal.style.display = 'none';
      errorModal.setAttribute('aria-hidden','true');
    };
  }

  // global JS error capture
  window.addEventListener('error', ev => {
    handleError(ev.error || ev.message || 'Unknown JS error');
  });
  window.addEventListener('unhandledrejection', ev => {
    handleError(ev.reason || 'Unhandled promise rejection');
  });

  // animation loop — keep rendering lightly for smoothIterer interactivity
  let lastRender = 0;
  function loop(t){
    // throttle to ~60fps
    const dt = t - lastRender;
    if(dt > 12){
      try {
        renderMain();
        if(CONFIG.juliaEnabled) renderJulia();
      } catch(err){ handleError(err); }
      lastRender = t;
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // initial hints in info
  infoBox.appendChild(document.createElement('br'));
  const hint = document.createElement('span');
  hint.className = 'small';
  hint.textContent = 'Mouse wheel zoom • Middle/left-drag pan • Arrows pan • W/S zoom • J toggle Julia';
  infoBox.appendChild(hint);

  // Make sure canvas tracks client size initially
  function initLayout(){
    mainCanvas.style.width = '100%';
    mainCanvas.style.height = '100%';
    state.pixelRatio = Math.max(1, window.devicePixelRatio || 1);
    resizeCanvasToDisplaySize(mainCanvas, glMain);
    glMain.viewport(0,0,mainCanvas.width, mainCanvas.height);
    renderMain();
  }
  initLayout();

  // expose some convenience on window for debugging
  window.mandelex = {
    state, renderMain, renderJulia, glMain
  };
// --- Tooltip logic ---
const tooltip = document.getElementById('coordTooltip');

mainCanvas.addEventListener('pointermove', e => {
  const rect = mainCanvas.getBoundingClientRect();
  const cx = ((e.clientX - rect.left) / rect.width) * state.scale + state.centerX - state.scale/2;
  const cy = ((rect.height - (e.clientY - rect.top)) / rect.height) * state.scale * (rect.height/rect.width) + state.centerY - state.scale/2;
  
  tooltip.style.left = e.clientX + 12 + 'px';
  tooltip.style.top = e.clientY + 12 + 'px';
  tooltip.textContent = `x: ${cx.toFixed(5)}, y: ${cy.toFixed(5)}`;
  tooltip.style.display = 'block';
});

mainCanvas.addEventListener('pointerleave', () => {
  tooltip.style.display = 'none';
});

})();
</script>
<a class="floating-pill right-pill" href="https://www.github.com/s2bd" target="_blank" rel="noopener">
  <i class="fa-brands fa-github"></i><span>Visit the creator</span>
</a>

</body>
</html>
